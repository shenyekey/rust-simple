///
/// 合集: Rust 编程之旅
/// 博主: 深夜飚键盘 (shenyekey)
/// 平台: 抖音、B站、微信, 关注一下啦
/// 键轴: 青轴
/// 当前: rust_demo_17
///
/// Rust 所有权，ownership
/// 我认为是一种机制
/// 所有权规定，每个值，任何时候有且只有一个所有者变量
/// 当所有者变量离开其作用域时，这个值就会被销毁和内存释放掉；
/// 
/// 那这个是关系到变量的销毁和释放，那就回到一个常用的词 gc
/// gc , 垃圾回收，什么是垃圾？
/// 程序运行时创建的变量，有些已经没有用了，但是还占用内存，没有被释放掉
/// 时间越久，内存占用越多，比如手机、电脑越用越卡，大部分都是这个原因
/// 像 Java ，Python 都有自动垃圾回收，由各自的虚拟机和解释器自动执行的
/// 像 C/C++ ，就要自己手动实现变量的创建和释放，如 C++ delete ；
/// 
/// 举个例子，说明所有权，很好理解

fn main() {
    // println!("Hello, world!");
    let s1 = String::from("深夜飚键盘");

    // 声明一个 s2, 我们把 s1 赋值给 s2 ,这时 s1 报错了
    let s2 = s1; 
    // 这里已经给出 value moved here 值已经移动了,此时 s2为所有者
    // s1 还是有错误的，这就是所有者机制，你在写代码时候，就已经给你提示了
    // 让你注意值的所有者变化
    // 当然你不改，也编译不过去
    println!("s2 = {}",s2);

    // 总结：一个值只能有一个所有者变量
    // 写代码时，就已经静态分析出来了，确保了内存安全
    // 完



    // 打印 s1，这样 s1 没问题，因为值 `深夜飚键盘`在 s1上，s1是所用者
    println!("s1 = {}",s1);
}
